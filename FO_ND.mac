/*
Code for verifying natural deduction proofs with FO.
@Reijo Jaakkola
@reijo.jaakkola@tuni.fi
*/

/*
As usual, connectives are denoted by
A = forall, E = exists, ! = not, & = and, | = or, ->, if...then, <-> = iff
*/

/*
Safe(r) version of charat. Checks whether the given index is legal,
and in positive case calls charat.

@param[in]	A		String
@param[in]	index 

@return				false, if index is illegal, and charat(A,index) otherwise.
*/
safeCharat(A,index):=block([],
	if (not(stringp(A)) or index < 1 or index > slength(A)) then (
		return(false))
	else (
		return(charat(A,index))))$

/*
Safe(r) version of substring. Checks whether the given indexes are lega,
and in positive case calls substring.

@param[in]	A			String
@param[in]	startIndex
@param[in]	endIndex

@return				false, if indexes were illegal, and substring(A, startIndex, endIndex) otherwise.
*/
safeSubstring(A,startIndex,endIndex) := block([],
	if (not(stringp(A)) or startIndex < 1 or endIndex > slength(A) + 1) then (
		return(false))
	else (
		return(substring(A,startIndex,endIndex))))$

/*
Helper function for checking that a given string is 
representing a number.

@param[in]  C   The string.

@return         True iff C is a string representing an integer.
*/
INTEGERP(C):=block([X],
    /*First check that C is a string.*/
    if (stringp(C) = false) then (return(false)),
    X:charlist(C),
    /*We will analyse the ASCII codes for each character in C.*/
    X:map(cint,X),
    /*Check that the ASCII code for every character in C is in the interval [48,57].*/
    X:map(lambda([x], 47 < x and x < 58),X),
    if(member(false,X)) then 
        (return(false))
    else return(true))$

/*
Type conversion from string to int.
NOTE: Assumes that the input is a string representing a number.

@param[in]  C   The string.

@return         The integer that C represents.
*/
CONVINT(C):=block([X, INT],
    INT:0, 
	X:charlist(C),
    /*We will analyse the ASCII codes for each character in C.*/
    X:map(cint,X),
    /*If c is a character representing a number, then the number is*/
    /*is the ASCII code of c minus 48.*/
    X:map(lambda([x], x - 48),X),
    /*Convert a list of digits into a number.*/
    for i:1 thru length(X) do(
        INT: INT + X[i]*10^(length(X)-i)),
    return(INT))$

/*
Function for finding the index where the innermost (binary) connective
in a formula begins.

@param[in]  F   Formula for which we whish to find the innermost operation.
@param[in]  d   Should be either 0 or 1, depending on whether the formula should
				contain outermost brackets or not.

@return         Index for the innermost operator, or -1 if none found.
*/
innerMostOperator(F, d) := block([index, c],
    index: -1,
    c: 0,
    for i:1 thru slength(F) do (
        if(charat(F,i)="(") then (  
            c: c + 1
        )
        else if(charat(F,i)=")") then (
            c: c - 1
        )
        /* Inner most operation is located in the place where c = d. */
        else if((charat(F,i)="&" or charat(F,i)="|" or charat(F,i)="-" or charat(F,i)="<") and c=d) then (
            index: i,
            /* Here to end the loop (why break does not work???). */
            i: slength(F)
        )
   ),
   return(index))$
  
/*
Function which adds outermost brackets to a formula if it does not have one.

@param[in]	F	Formula

@return			F or (F).
*/
addOutermostBrackets(F) := block([result],
	result: innerMostOperator(F,0),
	if(not(result = -1)) then (
		return(sconcat("(",F,")")))
	else (
		return(F)))$

/*
Function which removes all the given characters from a given string.
Does not affect the original string.

@param[in]  CHAR    Characters that should be removed.
@param[in]  S       String for which we want to do the clearing.

@return             Cleared string.
*/
clearString(CHAR,S):=block([],
    for i:1 thru length(CHAR) do (
        S: sremove(CHAR[i],S)
    ),
    return(S))$

/*
Function which checks whether a given formula contains any logical constants.

@param[in]  F       The given formula.

@return             True iff F has no logical constants.
*/
notContainsLogicalConstants(F):=block([Formula],
    cleanedFormula: clearString(["A","E","!","&","|","->","<->"],F),
    if (slength(cleanedFormula) = slength(F)) then (return(true))
    else (return(false)))$

/*
Function which verifies whether a given string represents a FO formula.

@param[in] F				String
@param[in] atomicFormulas	Set of atomic formulas that F can contain.
@param[in] variables		Set of variables that F can contain.

@return 					True iff F represents a FO formula.
*/	
isFoFormula(F, atomicFormulas, variables):=block([],
	if (not(stringp(F))) then (
		return(false)),
	if (notContainsLogicalConstants(F)) then (
		return(elementp(F, atomicFormulas)))
	else if (safeCharat(F,1) = "!") then (
		return(true))
	else if (safeCharat(F,1) = "A" or safeCharat(F,1) = "E") then (
		if (not(elementp(safeCharat(F,2), variables))) then (
			return(false))
		else (
			return(isFoFormula(safeSubstring(F,3,slength(F)+1), atomicFormulas, variables))))
	else (
		D: innerMostOperator(F, 1),
		if (safeCharat(F,D) = "|" or safeCharat(F,D) = "&") then (
			return(isFoFormula(substring(F,2,D),atomicFormulas,variables) and isFoFormula(substring(F,D+1,slength(F)+1),atomicFormulas,variables)))
		else if (safeCharat(F,D) = "-") then (
			return(isFoFormula(substring(F,2,D),atomicFormulas,variables) and isFoFormula(substring(F,D+2,slength(F)+1),atomicFormulas,variables)))
		else if (safeCharat(F,D) = "<") then (
			return(isFoFormula(substring(F,2,D),atomicFormulas,variables) and isFoFormula(substring(F,D+3,slength(F)+1),atomicFormulas,variables)))
		else (
			return(false))))$
			
/*
Example deduction:
OL ExEyA
		<AO EyA
				<AO A
				 ET3 ExA
				 ET4 EyExA>
		EE EyExA>
EE EyExA

Thus users indicate that they start a sub-deduction using '<' and '>'.
*/

/*
@param[in] Ded              The deduction given as an array.
@return 					True iff each sub-deduction that is started also ends.
*/
checkSubDeductions(Ded):=block([i,Counter],
	Counter: 0,
	for i:1 thru length(Ded) do
	(if(charat(Ded[i],1)="<") then
	(Counter: Counter + 1),
	if(charat(Ded[i],slength(Ded[i]))=">") then
	(Counter: Counter - 1)),
	if(Counter = 0) then
	(return(true))
	else(return(false)))$

/*
@param[in] claim			A single row in a deduction.
@return                     False if the row had incorrect form. Otherwise 
                            returns the formula that appeared in the row.
*/
checkDeductionRow(claim):=block([],
	start: safeSubstring(claim,1,3),
	if (safeCharat(start,1) = "<") then (
		return(checkDeductionRow(safeSubstring(start,2,slength(start)+1))))
	else if (start = "DT" or start = "DE" or start = "KE" or start = "RE" or start = "NE") then (
	    j:3,
		while (INTEGERP(safeCharat(claim,j)) and j <= slength(claim)) do (
			j:j+1),
		if (j = 3 or j > slength(claim)) then (
			return(false))
		else (
			return(safeSubstring(claim,j,slength(claim)+1))))
	else if(start = "KT" or start = "IE" or start = "EE") then (
		j:3,
		while (INTEGERP(safeCharat(claim,j)) and j <= slength(claim)) do (
			j:j+1),
		if (j = 3 or not (is(safeCharat(claim,j) = ",")) or j > slength(claim)) then (
			return(false))
		else (
			k:j+1,
			while (INTEGERP(safeCharat(claim,k)) and k <= slength(claim)) do (
				k:k+1),
			if (k = j+1 or k > slength(claim)) then (
				return(false))
			else (
				return(safeSubstring(claim,k,slength(claim)+1)))))
	else if(FIRSTP="IT" or FIRSTP="NT" or FIRSTP="OL" or FIRSTP="AO" or FIRSTP="ET") then (
		return(safeSubstring(claim,3,slength(claim)+1)))
	else (
		return(false)))$
		
/*
@param[in] Ded				The deduction given as an array.
@return						True iff each row in the deduction has the correct form.
*/
checkDeductionForm(Ded):=block([],
	output: map(checkDeductionRow,Ded),
	if (elementp(false,setify(output))) then (
		return(false))
	else (
		return(output)))$

/*
Function that verifies that the deduction has been written correctly.

@param[in]	Ded				The deduction as an array.
@param[in]	atomicFormulas	Atomic formulas that can appear in the formulas in the deduction.
@param[in]  variables		Variables that can appear in the deduction.
@return						True iff (hopefully) the deduction has a correct form.
*/
validateDeductionForm(Ded, atomicFormulas, variables):=block([],
	if (checkSubDeductions(Ded) = false) then (
		return(false))
	else (
		output: checkDeductionForm(Ded),
		if (output = false) then (
			return(false))
		else (
			valid: false,
			for i:1 thru length(output) do (
				valid: isFoFormula(output[i],atomicFormulas,variables)),
			return(valid))))$