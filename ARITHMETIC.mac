/*
Code for handling arithmetic terms.
@Reijo Jaakkola
@reijo.jaakkola@tuni.fi
*/

/*
This file will contain code that generates random terms in
the arithmetic vocabulary {+,*,0,1}, and also a conversion function
which converts from polish notation to infix notation.
*/

/*
Generate a random arithmetical term in Polish notation.

@param[in]		CALC	Number of summation and multiplication symbols the term should contain.
@param[in]		VAR		List of variables the term can contain.

@return					Random term of arithmetic vocabulary in polish notation
						that contains SUM many summation symbols and MULT many multiplication
						symbols.
*/
RandomArFormulaPolish(CALC,VAR):=block([],
	/*If there are no summations or multiplications*/
	/*left then add a random variable to the term.*/
	if (CALC = 0) then (
		/*Add 0 and 1 to the set of possible variables.*/
		VAR: cons("0",VAR),
		VAR: cons("1",VAR),
		randIndex: random(length(VAR))+1,
		return(VAR[randIndex])
	)
	else (
		/*Select randomly whether we choose summation or multiplication.*/
		coin: random(2),
		/*Then distribute the remaining resources for summation and multiplication randomly*/
		/*between the new two subformulas.*/
		dice: random(CALC),
		if (coin = 0) then (
			return(sconcat("+","(",RandomArFormulaPolish(CALC-dice-1,VAR),",",RandomArFormulaPolish(dice,VAR),")"))
		)
		else (
			return(sconcat("*","(",RandomArFormulaPolish(CALC-dice-1,VAR),",",RandomArFormulaPolish(dice,VAR),")"))
		)));
		
/*
Generate a random arithmetical term in infix notation.

@param[in]		CALC	Number of summation and multiplication symbols the term should contain.
@param[in]		VAR		List of variables the term can contain.

@return					Random term of arithmetic vocabulary in infix notation
						that contains SUM many summation symbols and MULT many multiplication
						symbols.
*/
RandomArFormulaInfix(CALC,VAR):=block([],
	/*If there are no summations or multiplications*/
	/*left then add a random variable to the term.*/
	if (CALC = 0) then (
		/*Add 0 and 1 to the set of possible variables.*/
		VAR: cons("0",VAR),
		VAR: cons("1",VAR),
		randIndex: random(length(VAR))+1,
		return(VAR[randIndex])
	)
	else (
		/*Select randomly whether we choose summation or multiplication.*/
		coin: random(2),
		/*Then distribute the remaining resources for summation and multiplication randomly*/
		/*between the new two subformulas.*/
		dice: random(CALC),
		if (coin = 0) then (
			return(sconcat("(",RandomArFormulaInfix(CALC-dice-1,VAR),"+",RandomArFormulaInfix(dice,VAR),")"))
		)
		else (
			return(sconcat("(",RandomArFormulaInfix(CALC-dice-1,VAR),"*",RandomArFormulaInfix(dice,VAR),")"))
		)));

/*
Function which removes all the given characters from a given string.
Does not affect the original string.

@param[in]	CHAR	Characters that should be removed.
@param[in]	S		String for which we want to do the clearing.

@return				Cleared string.
*/
ClearString(CHAR,S):=block([],
	for i:1 thru length(CHAR) do (
		S: sremove(CHAR[i],S)
	),
	return(S));

/*
Convert a given term in Polish notation into infix notation.

This function assumes that the term does not contain variables
or constants which have lenght longer than one!

@param[in]	T	Term in polish notation.

@return			Equivalent term in infix notation.
*/

ConvertPolishToInfix(T):=block([],
	/*First clear the string from brackets and apostrophes.*/
	T: ClearString(["(",",",")"],T),
	/*A list which will be treated as stack in this function.*/
	/*Stores the next multiplication operation that will be written.*/
	OPER_STACK: [],
	/*List that will be treated as stack in this function for storing*/
	/*the next variables that the calculation will affect.*/
	VAR_STACK: [],
	/*List that will be treated as stack for storing the progress made*/
	/*on previous operators.*/
	COUNTER_STACK: [],
	/*Counter for storing the progress.*/
	counter: 0,
	for i:1 thru slength(T) do (
		/*Function treats anything that is not summation*/
		/*or multiplication symbol as a variable, and thus*/
		/*they will increase the counter.*/
		if (charat(T,i) = "+" or charat(T,i) = "*") then (
			push(charat(T,i),OPER_STACK),
			/*Start a new counter.*/
			push(counter, COUNTER_STACK),
			counter: 0
		)
		else (
			push(charat(T,i),VAR_STACK),
			counter: counter + 1
		),
		if (counter = 2) then (
			while counter = 2 do (
				/*Pop the two variables from stack.*/
				VAR1: pop(VAR_STACK),
				VAR2: pop(VAR_STACK),
				/*Pop the operation.*/
				OPERATION: pop(OPER_STACK),
				/*Push the new string back.*/
				push(sconcat("(",VAR1,OPERATION,VAR2,")"),VAR_STACK),
				/*Pop the previous counter.*/
				counter: pop(COUNTER_STACK),
				/*Remember to increase the counter for the last operator,*/
				/*since we added now a new one.*/
				counter: counter + 1))),
	/*The resulting formula is the final element in the VAR_STACK.*/
	return(pop(VAR_STACK)));

/*
Function for finding the index for the innermost operator
in a term.

@param[in]	T	Term for which we whish to find the innermost operation.

@return			Index for the innermost operator, or -1 if none found.
*/
/*Funktio joka etsii kaavan sisimman konnektiivin*/
InnerMostOperator(T) := block([index, c],
	index: -1,
	c: 0,
	/*Puskemme listaan D merkin d mikäli tässä sijaitsee osa kaavan uloimpaa konnektiivia*/
	for i:1 thru slength(T) do (
		if(charat(T,i)="(") then (  
			c: c + 1
		)
		else if(charat(T,i)=")") then (
			c: c - 1
		)
		else if((charat(T,i)="*" or charat(T,i)="+") and c=1) then (
			index: i
		)
   ),
   return(index));